---
title: "Math for CG"
date: 2021-10-30
categories: 
use_math: true
tag: [math, computer graphics]
---

# 1. 서론
- 컴퓨터 그래픽스 제작 단계  
    - 모델링 -> 리깅(rigging) -> 애니메이션 -> 랜더링 -> 후처리
    - 모델링 : 물체를 컴퓨터가 처리할 수 있는 방식으로 표현(폴리곤 메시)하는 것
        - 폴리곤 메시 : 폴리곤으로 구성된 물체
    - 리깅 : 골격(skelton)을 구성한 후, 각각의 뼈(bone)의 움직임이 폴리곤 메시에 어떻게 반영될 것인가 정의한다.
    - 애니메이션 : 골격을 움직여 애니메이션을 정의
    - 랜더링 : 애니메이션 스크린 샷을 2차원 프레임으로 만드는 작업 (텍스처링, 라이팅)
    - 후처리 : 모션 블러, 초점 심도 처리
- 그래픽스 API
    - 게임프로그램 - 게임 엔진 - 그래픽스 API - GPU
    - 게임 엔진은 그래픽스 API를 기반으로 개발되며 그래픽스 API는 Direct3D와 OpenGL이 있다.  

# 2. 수학의 기초
## 2.1. 행렬과 벡터
- OpenGL은 열벡터를 사용하고 Direct3D는 행벡터를 사용한다.
- 정규화(normalization)  
벡터 $v$를 그 길이 $\vert \vert v \vert \vert$로 나누는 과정을 정규화라고 한다.
- 단위 벡터  
정규화를 통해 길이가 1인 벡터, $v/\vert \vert v \vert \vert$

## 2.2. 좌표계와 기저
 - 선형독립과 기저  
 ![2545C24E569D04232C](https://t1.daumcdn.net/cfile/tistory/24743D4C56A795C00D)
 - 기저(basis, 基底)란 어떤 벡터공간 V의 벡터들이 선형독립이면서 벡터공간 V 전체를 생성할 수 있다면 이 벡터들의 집합을 말합니다.  다른 말로 표현하자면, 기저는 "R^m의 임의의 원소를 표현하기 위해 필요한 최소한의 벡터로 이루어진 집합"입니다.  
출처: https://rfriend.tistory.com/164 [R, Python 분석과 프로그래밍의 친구 (by R Friend)]

- 표준 기저 : 주축에 나란한 기저
- 직교정규(orthonormal) : 서로 직교하는 단위 벡터

## 2.3. 내적
## 2.4. 벡터곱(cross product)
## 2.5. 직선 및 선형보간
- 매개변수 방정식(parametric equation)  

$$ p(t)=p_o+t(p_1-p_0) $$  
$$ p(t)=(1-t)p_o+tp_1 $$
  
- $(1-t)$와 $t$를 각각 $p_0$와 $p_1$에 대한 가중치(weight)
- $t$의 범위가 [0,1]일 때 $p(t)$는 $p_0$와 $p_1$의 선형보간이라고 한다.  

# 3. 모델링
## 3.1. 폴리곤 메시
- 물체를 표현하는 다양한 기법 중 폴리곤 메시가 많이 사용된다.
- GPU가 폴리곤 메시 처리에 최적화되어 있기 때문이다.
* 폴리곤 메시 표현  
    - 정점 배열과 인덱스 배열  
    인덱스 배열을 통해 효율적인 메모리 사용

## 3.2. 표면 노멀
- 삼각형 노멀 : ```v1 x v2 / ||v1 x v2||```
- 정점 노멀 : 일반적으로 삼각형 노멀들의 평균을 취함  

# 4. 좌표계와 변환
## 4.1. 2차원 변환의 행렬 표현
- 선형 변환(linear transform)  
: 확대축소 변환, 회전 변환 (행렬곱으로 나타낼 수 있음)  
: 이를 위해선 유클리드 기하학의 데카르트 좌표계가 필요하다.  
: 데카르트 좌표계에서의 선형변환은 새로운 기저(basis)로의 표현이다.

## 4.2. 아핀 변환
- 아핀 변환(affin transform)   
: 확대축소, 회전 및 이동까지 행렬곱으로 나타내기 위해선 차수가 하나 큰 동차 좌표가 필요하다.  
: 차수를 늘리면 이동까지 표현할 수 있는데 이런 변환을 아핀 변환이라고 한다. 즉 선형변환과 이동을 포함하는 것  
- 동차 좌표(homogeneous coordinates)  
: 차원 축소의 개념으로 한 축을 나머지 축의 배수 관계로 차원을 축소하여 생각하는 동차 좌표계는 한 축의 배수에 따라 동종의(homogeneous) 좌표를 얻을 수 있다. 이것이 사영 기하학이다.  
: 차원 추가의 개념으로 생성한 동차 좌표는 이동을 행렬곱으로 표현할 수 있게 해준다.

## 4.3. 3차원 변환의 행렬 표현
- 변환행렬을 ```[L|t]``` 이렇게 표현하면 L은 회전성분, t는 이동 성분이다. 결국 회전한 후 이동한 것으로 표현할 수 있다. 즉 자세를 잡고 원하는 위치로 이동..

## 4.4. 월드 변환
- 오브젝트 공간 (object space)  
: 하나의 물체를 모델링하는 데 사용된 좌표계
- 월드 공간 (world space)  
: 오브젝트 공간에서 정의된 물체들을 하나의 좌표계로 통합하는 좌표계  

## 4.5. 회전과 오브젝트 공간 기저
- 오브젝트 공간 기저  
: 물체가 움직이면 오브젝트 공간도 따라서 같이 움직인다.  
: 이때 움직인 오브젝트 공간의 기저는 월드 공간을 기준으로한 $ {u,v,n} $로 표현한다.  
: 따라서 이때의 변환 행렬은 다음과 같이 표현할 수 있다.  

$$ \begin{pmatrix} u_x & v_x & n_x \\\ u_y & v_y & n_y \\\ u_z & v_z & n_z \end{pmatrix} $$
  
## 4.6. 역변환
- 회전행렬의 역변환은 전치행렬과 같다.  $ R^T = R ^{-1} $  

# 5. 정점 처리
> -> GPU는 3차원의 폴리곤 데이터를 2차원 형태로 바꾸고  
-> 2차원 폴리곤 내부를 차지하는 픽셀들의 색상을 결정한다.  
이러한 픽셀들이 저장된 공간을 컬러 버퍼라하고  
스크린 전체의 픽셀 크기로 정해져있어 주기적으로 스크린에 복사된다.  
  
> -> **정점 쉐이더**에서 3차원 폴리곤 정점 데이터를 transform하고  
-> **래스터라이저**는 폴리곤 내부의 프래그먼트를 생성한다.  
-> 생성된 프래그먼트는 하나하나 프래그먼트 쉐이더로 들어가고  
-> **프래그먼트 쉐이더**는 라이팅과 텍스처링 작업을 거쳐 색상을 계산하고  
-> **출력 병합기**에서 이 색상과 컬러버퍼에 저장된 색상을 결합하여 컬러버퍼를 갱신한다.  

## 5.1. 노멀의 월드 변환
 - 정점 노멀  
 폴리곤(보통 삼각형)들의 메시(그물망)에서 폴리곤을 공유한 정점은 각 폴리곤의 노멀을 평균낸 정점 노멀을 갖고 있다.  
즉 3D 모델링 파일에는 정점 배열과 인덱스 배열이 등이 있고 정점 배열은 정점과 그 정점의 노멀로 구성된다.  

- 정점 노멀의 월드 변환  
정점을 월드 공간으로 transform 시키는 행렬로 정점 노멀을 transform하면 노멀을 유지할 수 없다.  
정점 노멀을 노멀하게 변환 시키는 방법은 다음과 같다.  
$$(L^{-1})^T \; , \, L은\,누적된\,선형변환$$

## 5.2. 뷰 변환
> 모든 물체가 월드 공간으로 월드 변환이 되었다면  
다음으로 스크린에 렌더링하기 위해 카메라의 위치와 방향을 설정해야 한다.  
이를 위해선 카메라의 위치 $EYE$와 오브젝트의 위치 $AT$ 그리고 카메라 위쪽 $UP$ (대부분 $y$방향임) 파라미터(카메라 외부파라메터)로 카메라 공간을 설정한다. 

### 5.2.1. 카메라 공간
$$ 카메라 공간 = \{ u,v,n, EYE \} $$  
$$ n  = {EYE-AT\over ||EYE-AT|| } \;,\;\; u = {UP\times n\over ||UP\times n||} \;,\;\; v=n \times u$$

### 5.2.2. 공간 이전과 뷰 행렬
- 공간 이전, 뷰 변환, 카메라 변환  
월드 공간에서 카메라 공간으로 공간 이전  
즉 카메라 좌표계를 월드 좌표계에 포개 놓는 과정  
이러한 변환을 뷰 변환 또는 카메라 변환이라 한다.  
- 기저 이전  
뷰 변환의 첫 단계는 이동 변환  
다음 단계는 회전 변환을 하게되는데 이 회전을 기저 이전이라 한다.
- 뷰 변환 표기  
그래서 뷰 변환은 $RT$가 되며 $M_{view}$ 로 표기한다.  

## 5.3. 오른손 좌표계와 왼손 좌표계
> Direct3D는 왼손 좌표계를 OpenGL은 오른손 좌표계를 사용한다.

# 5.4. 투영 변환
> 카메라의 자세를 **외부 파라메터**라고하고 렌즈를 선택하고 줌인/아웃을 조절하는 것은 **내부 파라메터** 조정이라 한다. **내부 파라메터**를 통해 **뷰 볼륨**을 정하고 이를 **투영 변환**하여 **클립 공간**을 구성한다.  

### 5.4.1. 뷰 프러스텀(frustum, 절두체)
- 뷰 볼륨  
: 카메라의 가시영역을 말하며 fovy, aspect, n, f 네 가지 파라미터를 사용해 결정된다. 이를 **뷰 프러스텀** 또는 **절두체**라한다.  
- 컬링(culling)  
: 계산 효율성을 위해 뷰 프러스텀 바깥에 놓인 물체는 걸러져 GPU 파이프라인에 들어가지 않도록 제거해주는 것을 **뷰 프러스텀 컬링**이라 한다. 

### 5.4.2. 투영 행렬
- 투영 변환  
피라미드 모양의 뷰 프러스텀을 2x2x2 크기의 정뮥면체 뷰 볼륨으로 변형하는 것  
3차원 공간 물체를 2차원 투영평면에 투영하는 것이 아님  
3차원 공간 내에서 원근법을 구현하는 것
정점 쉐이더가 수행하는 마지막 연산이다. 이후 데이터는 래스터라이저로 들어간다.  


